generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Setting {
  key       String   @id
  value     String
  encrypted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  sessions            Session[]
  settings            UserSettings?
  secrets             UserSecrets?
  rejectedSuggestions RejectedSuggestion[]
}

model Session {
  id         String   @id
  userId     String
  createdAt  DateTime @default(now())
  lastSeenAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserSettings {
  userId    String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserSecrets {
  userId    String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum JobRunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum JobRunTrigger {
  manual
  schedule
  auto
}

model JobSchedule {
  jobId     String   @id
  cron      String
  enabled   Boolean  @default(true)
  timezone  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JobRun {
  id           String        @id @default(cuid())
  jobId        String
  userId       String?
  trigger      JobRunTrigger
  dryRun       Boolean       @default(false)
  status       JobRunStatus
  startedAt    DateTime      @default(now())
  finishedAt   DateTime?
  summary      Json?
  errorMessage String?

  logs JobLogLine[]

  @@index([jobId, startedAt])
  @@index([userId, startedAt])
}

model JobLogLine {
  id      Int      @id @default(autoincrement())
  runId   String
  time    DateTime @default(now())
  level   String
  message String
  context Json?

  run JobRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, time])
}

model CuratedCollection {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items CuratedCollectionItem[]
}

model CuratedCollectionItem {
  id           Int    @id @default(autoincrement())
  collectionId String
  ratingKey    String
  title        String

  collection CuratedCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, ratingKey])
  @@index([collectionId])
}

enum ImmaculateTasteStatus {
  pending
  active
}

enum DownloadApprovalStatus {
  none
  pending
  approved
  rejected
}

enum RejectedSuggestionSource {
  immaculate
  watched
}

enum RejectedSuggestionExternalSource {
  tmdb
  tvdb
}

model RejectedSuggestion {
  id             String                           @id @default(cuid())
  userId         String
  mediaType      String // 'movie' | 'tv' (kept simple for sqlite/prisma)
  externalSource RejectedSuggestionExternalSource
  externalId     String
  source         RejectedSuggestionSource
  // For watched-based rejections, this identifies which watched collection produced the suggestion.
  // - 'immaculateTaste' | 'recentlyWatched' | 'changeOfTaste'
  // (stored as string for sqlite/prisma simplicity)
  collectionKind String?
  reason         String? // 'reject' | 'remove' (optional)
  createdAt      DateTime                         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, mediaType, externalSource, externalId])
  @@index([userId, mediaType])
  @@index([userId, mediaType, source])
}

model ImmaculateTasteMovie {
  tmdbId Int     @id
  title  String?

  status ImmaculateTasteStatus @default(pending)
  points Int                   @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([points])
  @@index([tmdbVoteAvg])
}

enum WatchedRecommendationStatus {
  pending
  active
}

model WatchedMovieRecommendation {
  collectionName String
  tmdbId         Int
  title          String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, tmdbId])
  @@index([collectionName, status])
  @@index([collectionName, points])
  @@index([collectionName, tmdbVoteAvg])
}

// Library-specific points dataset for Immaculate Taste (movies).
// This prevents multi-library setups from overriding each other.
model ImmaculateTasteMovieLibrary {
  librarySectionKey String
  tmdbId            Int
  title             String?

  status ImmaculateTasteStatus @default(pending)
  points Int                   @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  // Observatory approvals (optional): gate ARR requests behind user swipes.
  downloadApproval DownloadApprovalStatus @default(none)
  sentToRadarrAt   DateTime?
  sentToSonarrAt   DateTime?

  // Cached artwork (optional). Store TMDB poster path (e.g. "/abc.jpg").
  tmdbPosterPath String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([librarySectionKey, tmdbId])
  @@index([librarySectionKey])
  @@index([librarySectionKey, status])
  @@index([librarySectionKey, points])
  @@index([librarySectionKey, tmdbVoteAvg])
}

// Library-specific points dataset for "Based on Latest Watched" collections (movies).
model WatchedMovieRecommendationLibrary {
  collectionName    String
  librarySectionKey String
  tmdbId            Int
  title             String?

  status WatchedRecommendationStatus @default(pending)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  // Observatory approvals (optional): gate ARR requests behind user swipes.
  downloadApproval DownloadApprovalStatus @default(none)
  sentToRadarrAt   DateTime?

  // Cached artwork (optional). Store TMDB poster path (e.g. "/abc.jpg").
  tmdbPosterPath String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, librarySectionKey, tmdbId])
  @@index([librarySectionKey])
  @@index([librarySectionKey, collectionName, status])
  @@index([librarySectionKey, collectionName, tmdbVoteAvg])
  @@index([librarySectionKey, collectionName, downloadApproval])
  @@index([librarySectionKey, collectionName, sentToRadarrAt])
  @@index([tmdbId])
}

model ImmaculateTasteShow {
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId Int     @id
  tmdbId Int?
  title  String?

  status ImmaculateTasteStatus @default(pending)
  points Int                   @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tmdbId])
  @@index([status])
  @@index([points])
  @@index([tmdbVoteAvg])
}

// Library-specific points dataset for Immaculate Taste (TV).
model ImmaculateTasteShowLibrary {
  librarySectionKey String
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId            Int
  tmdbId            Int?
  title             String?

  status ImmaculateTasteStatus @default(pending)
  points Int                   @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  // Observatory approvals (optional): gate ARR requests behind user swipes.
  downloadApproval DownloadApprovalStatus @default(none)
  sentToRadarrAt   DateTime?
  sentToSonarrAt   DateTime?

  // Cached artwork (optional). Store TMDB poster path (e.g. "/abc.jpg").
  tmdbPosterPath String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([librarySectionKey, tvdbId])
  @@index([librarySectionKey])
  @@index([tmdbId])
  @@index([librarySectionKey, status])
  @@index([librarySectionKey, points])
  @@index([librarySectionKey, tmdbVoteAvg])
}

model WatchedShowRecommendation {
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  collectionName String
  tvdbId         Int
  tmdbId         Int?
  title          String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, tvdbId])
  @@index([tmdbId])
  @@index([collectionName, status])
  @@index([collectionName, points])
  @@index([collectionName, tmdbVoteAvg])
}

// Library-specific points dataset for "Based on Latest Watched" collections (TV).
model WatchedShowRecommendationLibrary {
  collectionName    String
  librarySectionKey String
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId            Int
  tmdbId            Int?
  title             String?

  status WatchedRecommendationStatus @default(pending)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  // Observatory approvals (optional): gate ARR requests behind user swipes.
  downloadApproval DownloadApprovalStatus @default(none)
  sentToSonarrAt   DateTime?

  // Cached artwork (optional). Store TMDB poster path (e.g. "/abc.jpg").
  tmdbPosterPath String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, librarySectionKey, tvdbId])
  @@index([librarySectionKey])
  @@index([tmdbId])
  @@index([librarySectionKey, collectionName, status])
  @@index([librarySectionKey, collectionName, tmdbVoteAvg])
  @@index([librarySectionKey, collectionName, downloadApproval])
  @@index([librarySectionKey, collectionName, sentToSonarrAt])
}

// Legacy table preserved by historical migrations (not used by Prisma Client).
// We keep it in the database for debugging/back-compat reference, so Prisma
// migrations must NOT attempt to drop it.
model ImmaculateTasteMovieLegacy {
  ratingKey String   @id
  title     String?
  points    Int
  tmdbId    Int?
  createdAt DateTime
  updatedAt DateTime

  @@map("ImmaculateTasteMovieLegacy")
  @@ignore
}
