generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Setting {
  key       String   @id
  value     String
  encrypted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  sessions Session[]
  settings UserSettings?
  secrets  UserSecrets?
}

model Session {
  id         String   @id
  userId     String
  createdAt  DateTime @default(now())
  lastSeenAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserSettings {
  userId    String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserSecrets {
  userId    String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum JobRunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum JobRunTrigger {
  manual
  schedule
}

model JobSchedule {
  jobId     String   @id
  cron      String
  enabled   Boolean  @default(true)
  timezone  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JobRun {
  id           String        @id @default(cuid())
  jobId        String
  userId       String?
  trigger      JobRunTrigger
  dryRun       Boolean       @default(false)
  status       JobRunStatus
  startedAt    DateTime      @default(now())
  finishedAt   DateTime?
  summary      Json?
  errorMessage String?

  logs JobLogLine[]

  @@index([jobId, startedAt])
  @@index([userId, startedAt])
}

model JobLogLine {
  id      Int      @id @default(autoincrement())
  runId   String
  time    DateTime @default(now())
  level   String
  message String
  context Json?

  run JobRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, time])
}

model CuratedCollection {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items CuratedCollectionItem[]
}

model CuratedCollectionItem {
  id           Int    @id @default(autoincrement())
  collectionId String
  ratingKey    String
  title        String

  collection CuratedCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, ratingKey])
  @@index([collectionId])
}

enum ImmaculateTasteStatus {
  pending
  active
}

model ImmaculateTasteMovie {
  tmdbId Int @id
  title  String?

  status ImmaculateTasteStatus @default(pending)
  points Int                  @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([points])
  @@index([tmdbVoteAvg])
}

enum WatchedRecommendationStatus {
  pending
  active
}

model WatchedMovieRecommendation {
  collectionName String
  tmdbId          Int
  title           String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, tmdbId])
  @@index([collectionName, status])
  @@index([collectionName, points])
  @@index([collectionName, tmdbVoteAvg])
}

// Library-specific points dataset for Immaculate Taste (movies).
// This prevents multi-library setups from overriding each other.
model ImmaculateTasteMovieLibrary {
  librarySectionKey String
  tmdbId            Int
  title             String?

  status ImmaculateTasteStatus @default(pending)
  points Int                  @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([librarySectionKey, tmdbId])
  @@index([librarySectionKey])
  @@index([librarySectionKey, status])
  @@index([librarySectionKey, points])
  @@index([librarySectionKey, tmdbVoteAvg])
}

// Library-specific points dataset for "Based on Latest Watched" collections (movies).
model WatchedMovieRecommendationLibrary {
  collectionName     String
  librarySectionKey  String
  tmdbId             Int
  title              String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, librarySectionKey, tmdbId])
  @@index([librarySectionKey])
  @@index([librarySectionKey, collectionName, status])
  @@index([librarySectionKey, collectionName, points])
  @@index([librarySectionKey, collectionName, tmdbVoteAvg])
  @@index([tmdbId])
}

model ImmaculateTasteShow {
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId Int @id
  tmdbId Int?
  title  String?

  status ImmaculateTasteStatus @default(pending)
  points Int                  @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tmdbId])
  @@index([status])
  @@index([points])
  @@index([tmdbVoteAvg])
}

// Library-specific points dataset for Immaculate Taste (TV).
model ImmaculateTasteShowLibrary {
  librarySectionKey String
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId Int
  tmdbId Int?
  title  String?

  status ImmaculateTasteStatus @default(pending)
  points Int                  @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([librarySectionKey, tvdbId])
  @@index([librarySectionKey])
  @@index([tmdbId])
  @@index([librarySectionKey, status])
  @@index([librarySectionKey, points])
  @@index([librarySectionKey, tmdbVoteAvg])
}

model WatchedShowRecommendation {
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  collectionName String
  tvdbId         Int
  tmdbId         Int?
  title          String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, tvdbId])
  @@index([tmdbId])
  @@index([collectionName, status])
  @@index([collectionName, points])
  @@index([collectionName, tmdbVoteAvg])
}

// Library-specific points dataset for "Based on Latest Watched" collections (TV).
model WatchedShowRecommendationLibrary {
  collectionName    String
  librarySectionKey String
  // TV collections are keyed by tvdbId because Plex/Sonarr mapping is TVDB-first.
  tvdbId Int
  tmdbId Int?
  title  String?

  status WatchedRecommendationStatus @default(pending)
  points Int                         @default(0)

  tmdbVoteAvg   Float?
  tmdbVoteCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([collectionName, librarySectionKey, tvdbId])
  @@index([librarySectionKey])
  @@index([tmdbId])
  @@index([librarySectionKey, collectionName, status])
  @@index([librarySectionKey, collectionName, points])
  @@index([librarySectionKey, collectionName, tmdbVoteAvg])
}

// Legacy table preserved by historical migrations (not used by Prisma Client).
// We keep it in the database for debugging/back-compat reference, so Prisma
// migrations must NOT attempt to drop it.
model ImmaculateTasteMovieLegacy {
  ratingKey String @id
  title     String?
  points    Int
  tmdbId    Int?
  createdAt DateTime
  updatedAt DateTime

  @@map("ImmaculateTasteMovieLegacy")
  @@ignore
}


